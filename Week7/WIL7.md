https://velog.io/@yachae1101/WIL-GDSC-OC-BE-STUDY-WEEK-7

7주차 WIL입니다.

## ✔️ SOLID : 객체 지향 설계 5대 원칙

이전까지 `객체 지향`의 `4대 특성`들을 학습했다.

그렇다면, 이러한 `객체 지향의 특성`들을 `올바르게 활용`하여 객체 지향 `프로그램을 설계`하는 방법은 무엇일까?

`객체 지향 설계`의 가장 기본적인 원칙이 바로 `SOLID` `객체 지향 설계 5대 원칙`이다.

### ▪️ SOLID
- SRP(Single Responsibility) : 단일 책임 원칙
- OCP (Open-Closed Principle) : 개방 폐쇄 원칙
- LSP (Liskov Substitution Principle) : 리스코프 치환 원칙
- ISP (Interface Segregation Principle) : 인터페이스 분리 원칙
- DIP (Dependency Inversion Principle) : 의존성 역전 원칙


## ✔️ SRP : 단일 책임 원칙

### ▪️ SRP❔
`단일 책임 원칙`이란, 하나의 클래스는, 단 하나의 역할(책임)을 가져야 한다는 원칙이다.

예를 들어, `대학생`이라는 클래스는,
학교에서는 `'학생'으로서의 '역할(공부하기, 시험보기 등)'`을 수행하고,
편의점에서는 `'아르바이트생'으로서의 '역할(계산하기, 정리하기 등)'`을 수행한다면,

이는 `대학생`이라는 클래스가, 둘 이상의 '역할'을 수행하는 것으로, SRP 원칙에 위배되는 예라고 할 수 있다.

위의 예시에서 `대학생` 클래스를 `학생`과 `아르바이트생`의 두 클래스로 분리하고
`학생` 클래스에서는 학생으로서의 '역할'만을 수행하도록 하고,
`아르바이트생` 클래스에서는 아르바이트생으로서의 '역할'만을 수행하도록 해야 한다는 원칙이다.

### ▪️ 적용의 장점
- SRP 원칙을 적용하여, 하나의 클래스가 하나의 역할(책임)을 가지도록 설계한다면, `학생`이나, `아르바이트생` 이라는 클래스명 만으로 역할을 이해 할 수 있다.
- 클래스의 단일 책임이 변경될 때, 다른 책임에 영항을 미치지 않아 수정에 용이하다.


## ✔️ OCP : 개방 폐쇄 원칙

### ▪️ OCP❔
`개방 폐쇄 원칙`이란, 자신의 확장에는 열려 있고, 주변의 변화에는 닫혀 있어야 한다는 원칙이다.

예를 들어, 편의점에서 손님이 물건을 구매하는 상황을 생각해보자.
편의점의 근무는 교대로 이루어진다. 따라서 판매하는 행위를 하는 `근무자`는 `점장님`일 수도, `아르바이트생`일 수도 있다.
하지만, 근무자가 누구인지에 따라 상관없이 `손님`은 `구매하는 행위`를 동일하게 할 수 있다.

위의 예시에서,
자신의 확장에는 열려 있다? : `편의점의 근무자`는 점장님일 수도, 아르바이트생일 수도 있다. `편의점 근무자`는 자신의 확장에 열려 있다고 할 수 있다.

주변의 변화에는 닫혀 있다? : `손님`은 근무자가 바뀌는 주변의 변화에 상관없이 동일한 구매 행위를 할 수 있다. 따라서 `손님`은 주변의 변화에 닫혀 있다고 할 수 있다.

### ▪️ 적용의 장점
- OCP 원칙을 적용하면, `손님`의 코드를 수정하지 않더라도, 손님의 행위를 지원하는 `근무자`를 마치 모듈처럼 자유롭게 교체할 수 있기 때문에, 기존의 코드를 수정하지 않고도 새로운 기능을 추가할 수 있도록 한다.
- 이로써, 코드의 확장성과 유연성이 증가한다.


## ✔️ LSP : 리스코프 치환 원칙

### ▪️ LSP❔
`리스코프 치환 법칙`이란, 서브 타입은 언제나 자신의 기반 타입(base)으로 교체할 수 있어야 한다는 원칙이다.

즉, 다시말해, 하위 클래스의 인스턴스는, 상위 클래스의 인스턴스 역할을 하는 데 문제가 없어야 한다는 것이다.

예를 들어, `사람`이라는 상위 클래스의, 하위 클래스로 `학생`과 `아르바이트생`이 있다면,
하위 클래스의 `학생`과 `아르바이트생`은 상위 클래스의 `사람`의 역할을 하는 데 문제가 없어야 한다는 것이다.

만약 `아버지`라는 상위 클래스의, 하위 클래스로 `딸`이 있다면,
하위 클래스의 `딸`은 상위 클래스의 `아버지`의 역할을 할 수 없기 때문에,
이는 LSP 원칙에 위배되는 예시라 할 수 있다.

### ▪️ 적용의 장점
- LSP 원칙이 올바르게 적용되어야, 객체 지향의 상속이라는 특성을 올바르게 활용할 수 있다.


## ✔️ ISP : 인터페이스 분리 원칙

### ▪️ ISP❔
`인터페이스 분리 원칙`이란, 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다는 원칙이다.

다시 말하자면, 클라이언트가 실제로 사용하는 메서드들만을 담아 인터페이스를 만들어야 한다는 것이다.

위의 SRP 원칙의 예에서, `대학생`이라는 클래스는,
학교에서는 `'학생'으로서의 '역할(공부하기, 시험보기 등)'`을 수행하고,
편의점에서는 `'아르바이트생'으로서의 '역할(계산하기, 정리하기 등)'`을 수행한다면,

`학교에서의 인터페이스`는 학생으로서의 역할(공부하기, 시험보기 등)만을 담아야 하고,
`편의점에서의 인터페이스`는 아르바이트생으로서의 역할(계산하기, 정리하기 등)만을 담아야 한다.

만약, `편의점에서의 인터페이스`가, 학생의 기능인 '시험보기' 메서드에 의존한다면, 이는 ISP 원칙을 위반한 예시라 할 수 있다.


### ▪️ 적용의 장점
- ISP 원칙을 준수하면 인터페이스가 작고, 관련 기능에 집중되어 있게 된다. 
클라이언트는 필요한 기능만을 인터페이스를 통해 사용하므로, 사용하지 않는 기능에 대한 의존성을 줄일 수 있다.
- 인터페이스가 명확하게 정의된다. 이로써 인터페이스의 의도를 명확하게 이해하고 사용할 수 있도록 한다.

## ✔️ DIP : 의존성 역전 원칙

### ▪️ DIP❔
`의존성 역전 원칙`이란, 자신보다 변하기 쉬운 것에 의존하지 말라는 원칙이다.

위의 OCP 원칙의 예에서,
편의점의 근무자가 누구인지에 상관없이, `손님`은 `구매하는 행위`를 동일하게 할 수 있어야 한다.
그렇다면 `손님`은 구체적인 근무자, `점장님`이나 특정 `아르바이트생`에게 의존해서는 안된다.
즉, `손님`은 자신보다 변하기 쉬운 특정 근무자에 의존해서는 안된다.

따라서, `손님`은 특정 근무자가 아닌, `추상화된 근무자 인터페이스`에만 의존하게 하여, 근무자가 누구인지에 상관없이 손님은 영향을 받지 않는 형태로 구성해야 한다는 것이 DIP 원칙이다.

### ▪️ 적용의 장점
- DIP 원칙을 적용하면, `손님`은 하위 수준의 모듈에 직접 의존하지 않고, `추상화된 인터페이스(근무자 인터페이스)`에 의존하도록 하여, 하위 수준 모듈의 변경이 상위 수준 모듈에 미치는 영향을 최소화할 수 있다.